# Control Structures in C++

All programs could be written in terms of only three control structures, namely, the sequence structure, the selection structure and the repetition structure.

* Sequence Structure
  * The sequence structure is built into C++. 
  * Unless directed otherwise, C++ statements execute one after the other in the order in which they are writtenâ€”that is, in 
    sequence.
* Selection Structure
  * C++ provides three types of selection statements - ```if, if-else and switch```.
  * The if selection statement is a single-selection statement because it selects or ignores a single action. 
  * The if...else statement is called a double-selection statement because it selects between two different actions (or groups of actions). 
  * The switch selection statement is called a multiple-selection statement because it selects among many different actions (or groups of actions).
* Repettion Structure
  * C++ provides three types of repetition statements that enable programs to perform statements repeatedly as long as a condition remains true - ```while```, ```do-while```, and ```for```.

**Compound Statement**
A compound statement is a group of statements (each of them terminated by its own semicolon), but all grouped together in a block, and enclosed in curly braces:

```C++
{ 
statement1; 
statement2; 
statement3; 
}
```

## if Statement

```C++
if (condition)
  statement
```

### if-else
```C++
if (condition)
  statement
else
  statement
```

```C++
if (condition)
  statement
else if (condition)
  statement
else
  statement
```

## switch
Its purpose is to check for a value among a number of possible constant expressions. It is something similar to concatenating if-else statements, but limited to constant expressions. Its most typical syntax is:

```C++
switch (expression)
{
  case constant1:
     group-of-statements-1;
     break;
  case constant2:
     group-of-statements-2;
     break;
  .
  .
  .
  default:
     default-group-of-statements
}
```
It works in the following way: switch evaluates expression and checks if it is equivalent to constant1; if it is, it executes group-of-statements-1 until it finds the break statement. When it finds this break statement, the program jumps to the end of the entire switch statement (the closing brace).

If expression was not equal to constant1, it is then checked against constant2. If it is equal to this, it executes group-of-statements-2 until a break is found, when it jumps to the end of the switch.

Finally, if the value of expression did not match any of the previously specified constants (there may be any number of these), the program executes the statements included after the default: label, if it exists (since it is optional).

#### Switch fall through
If the example above lacked the break statement after the first group for case one, the program would not jump automatically to the end of the switch block after printing x is 1, and would instead continue executing the statements in case two (thus printing also x is 2). It would then continue doing so until a break statement is encountered, or the end of the switch block. This makes unnecessary to enclose the statements for each case in braces {}, and can also be useful to execute the same group of statements for different possible values. For example:
	
```C++
switch (x) {
  case 1:
  case 2:
  case 3:
    cout << "x is 1, 2 or 3";
    break;
  default:
    cout << "x is not 1, 2 nor 3";
  }
```

Notice that switch is limited to compare its evaluated expression against labels that are constant expressions. It is not possible to use variables as labels or ranges, because they are not valid C++ constant expressions.

## while
```C++
while (expression)
  statement
```

## do-while
```C++
do
{
  statement;
} while(expression);
```

## for

```C++
for (initialization expression; condition; update expression)
```

### Range based for loop
```C++
for ( declaration : range ) statement;
```
This kind of for loop iterates over all the elements in range, where declaration declares some variable able to take the value of an element in this range. Ranges are sequences of elements, including arrays, containers, and any other type supporting the functions begin and end.

```C++
// range-based for loop
#include <iostream>
#include <string>
using namespace std;

int main ()
{
  string str {"Hello!"};
  for (char c : str)
  {
    cout << "[" << c << "]";
  }
  cout << '\n';
}
```

## Jump Statements
### break
break leaves a loop, even if the condition for its end is not fulfilled. It can be used to end an infinite loop, or to force it to end before its natural end.


### continue
The continue statement causes the program to skip the rest of the loop in the current iteration, as if the end of the statement block had been reached, causing it to jump to the start of the following iteration.

## Unconditional branching with goto
goto allows to make an absolute jump to another point in the program. This unconditional jump ignores nesting levels, and does not cause any automatic stack unwinding. Therefore, it is a feature to use with care, and preferably within the same block of statements, especially in the presence of local variables.

The destination point is identified by a label, which is then used as an argument for the goto statement. A label is made of a valid identifier followed by a colon (:).

goto is generally deemed a low-level feature, with no particular use cases in modern higher-level programming paradigms generally used with C++.  

```C++
// goto loop example
#include <iostream>
using namespace std;

int main ()
{
  int n=10;
mylabel:
  cout << n << ", ";
  n--;
  if (n>0) goto mylabel;
  cout << "liftoff!\n";
}
```


